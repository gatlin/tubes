<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Tubes</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Tubes.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Tubes.html">Source</a></li><li><a href="/package/tubes-2.1.1.0">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">tubes-2.1.1.0: Write stream processing computations with side effects in a series of
tubes.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) 2014, 2016 Gatlin Johnson &lt;gatlin@niltag.net&gt;</td></tr><tr><th>License</th><td>GPL-3</td></tr><tr><th>Maintainer</th><td>gatlin@niltag.net</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>Trustworthy</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Tubes</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Tube</a></li><li><a href="#g:2">Sources</a></li><li><a href="#g:3">Sinks</a></li><li><a href="#g:4">Channels</a></li><li><a href="#g:5">Pump</a></li><li><a href="#g:6">Utilities</a></li><li><a href="#g:7">Miscellaneous</a></li><li><a href="#g:8">Re-exports</a></li><li><a href="#g:9">Example</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Write effect-ful stream processing functions and compose them into a series of
tubes.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Tube">Tube</a> a b = FreeT (<a href="Tubes-Core.html#t:TubeF">TubeF</a> a b)</li><li class="src short"><a href="#v:yield">yield</a> :: Monad m =&gt; b -&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m ()</li><li class="src short"><a href="#v:await">await</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m a</li><li class="src short"><a href="#v:-62--60-">(&gt;&lt;)</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m r -&gt; <a href="Tubes.html#t:Tube">Tube</a> b c m r -&gt; <a href="Tubes.html#t:Tube">Tube</a> a c m r</li><li class="src short"><a href="#v:runTube">runTube</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> () () m r -&gt; m r</li><li class="src short"><a href="#v:halt">halt</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m ()</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Source">Source</a> m a = <a href="#v:Source">Source</a> {<ul class="subs"><li><a href="#v:sample">sample</a> :: <a href="Tubes.html#t:Tube">Tube</a> () a m ()</li></ul>}</li><li class="src short"><a href="#v:reduce">reduce</a> :: Monad m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Tubes.html#t:Tube">Tube</a> () a m () -&gt; m b</li><li class="src short"><a href="#v:merge">merge</a> :: Monad m =&gt; <a href="Tubes.html#t:Source">Source</a> m a -&gt; <a href="Tubes.html#t:Source">Source</a> m a -&gt; <a href="Tubes.html#t:Source">Source</a> m a</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Sink">Sink</a> m a = <a href="#v:Sink">Sink</a> {<ul class="subs"><li><a href="#v:pour">pour</a> :: <a href="Tubes.html#t:Tube">Tube</a> a () m ()</li></ul>}</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Channel">Channel</a> m a b = <a href="#v:Channel">Channel</a> {<ul class="subs"><li><a href="#v:tune">tune</a> :: <a href="Tubes.html#t:Tube">Tube</a> a b m ()</li></ul>}</li><li class="src short"><a href="#v:tee">tee</a> :: Monad m =&gt; <a href="Tubes.html#t:Sink">Sink</a> m a -&gt; <a href="Tubes.html#t:Channel">Channel</a> m a a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Pump">Pump</a> b a = CofreeT (<a href="Tubes-Core.html#t:PumpF">PumpF</a> b a)</li><li class="src short"><a href="#v:send">send</a> :: Comonad w =&gt; b -&gt; <a href="Tubes.html#t:Pump">Pump</a> a b w r -&gt; <a href="Tubes.html#t:Pump">Pump</a> a b w r</li><li class="src short"><a href="#v:recv">recv</a> :: Comonad w =&gt; <a href="Tubes.html#t:Pump">Pump</a> a b w r -&gt; (a, <a href="Tubes.html#t:Pump">Pump</a> a b w r)</li><li class="src short"><a href="#v:pumpT">pumpT</a> :: Comonad w =&gt; w r -&gt; (w r -&gt; b -&gt; w r) -&gt; (w r -&gt; (a, w r)) -&gt; <a href="Tubes.html#t:Pump">Pump</a> a b w r</li><li class="src short"><a href="#v:lfold">lfold</a> :: (x -&gt; a -&gt; x) -&gt; (x -&gt; (b, x)) -&gt; x -&gt; <a href="Tubes.html#t:Pump">Pump</a> b a Identity x</li><li class="src short"><a href="#v:stream">stream</a> :: (Monad m, Comonad w) =&gt; (a -&gt; b -&gt; r) -&gt; <a href="Tubes.html#t:Pump">Pump</a> c d w a -&gt; <a href="Tubes.html#t:Tube">Tube</a> c d m b -&gt; m r</li><li class="src short"><a href="#v:streamM">streamM</a> :: (Monad m, Comonad w) =&gt; (a -&gt; b -&gt; r) -&gt; <a href="Tubes.html#t:Pump">Pump</a> c d w (m a) -&gt; <a href="Tubes.html#t:Tube">Tube</a> c d m b -&gt; m r</li><li class="src short"><a href="#v:cat">cat</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m r</li><li class="src short"><a href="#v:for">for</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m r -&gt; (b -&gt; <a href="Tubes.html#t:Tube">Tube</a> a c m s) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a c m r</li><li class="src short"><a href="#v:each">each</a> :: (Monad m, Foldable t) =&gt; t b -&gt; <a href="Tubes.html#t:Tube">Tube</a> () b m ()</li><li class="src short"><a href="#v:every">every</a> :: (Foldable t, Monad m) =&gt; t b -&gt; <a href="Tubes.html#t:Tube">Tube</a> () (Maybe b) m ()</li><li class="src short"><a href="#v:map">map</a> :: Monad m =&gt; (a -&gt; b) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m r</li><li class="src short"><a href="#v:drop">drop</a> :: Monad m =&gt; Int -&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m r</li><li class="src short"><a href="#v:take">take</a> :: Monad m =&gt; Int -&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m ()</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m ()</li><li class="src short"><a href="#v:filter">filter</a> :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m r</li><li class="src short"><a href="#v:unyield">unyield</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> x b m () -&gt; m (Maybe (b, <a href="Tubes.html#t:Tube">Tube</a> x b m ()))</li><li class="src short"><a href="#v:pass">pass</a> :: Monad m =&gt; a -&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m () -&gt; m (Maybe (b, <a href="Tubes.html#t:Tube">Tube</a> a b m ()))</li><li class="src short"><a href="#v:mapM">mapM</a> :: Monad m =&gt; (a -&gt; m b) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m r</li><li class="src short"><a href="#v:sequence">sequence</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> (m a) a m r</li><li class="src short"><a href="#v:stop">stop</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a () m r</li><li class="src short"><a href="#v:prompt">prompt</a> :: MonadIO m =&gt; <a href="Tubes.html#t:Source">Source</a> m String</li><li class="src short"><a href="#v:display">display</a> :: MonadIO m =&gt; <a href="Tubes.html#t:Sink">Sink</a> m String</li><li class="src short"><a href="#v:liftT">liftT</a> :: (MonadTrans t, Monad m) =&gt; FreeT f m a -&gt; t m (FreeF f a (FreeT f m a))</li><li class="src short"><a href="#v:runFreeT">runFreeT</a> :: FreeT f m a -&gt; m (FreeF f a (FreeT f m a))</li></ul></div><div id="interface"><h1 id="g:1">Tube</h1><div class="doc"><p>A <code><a href="Tubes.html#t:Tube">Tube</a></code> is a computation which may <code><a href="Tubes.html#v:await">await</a></code> values from an upstream source,
<code><a href="Tubes.html#v:yield">yield</a></code> values to a downstream receiver, or both. <code><a href="Tubes.html#t:Tube">Tube</a></code>s may be composed in
series to build complex stream processors using the '(&gt;&lt;)' operator.</p><p><code><a href="Tubes.html#t:Tube">Tube</a></code>s are also monad transformers so you can add stream processing
capabilities to any base monad.</p><p>There are three varieties of <code><a href="Tubes.html#t:Tube">Tube</a></code>s which have different properties:
<code><a href="Tubes.html#t:Source">Source</a></code>s, <code><a href="Tubes.html#t:Sink">Sink</a></code>s, and <code><a href="Tubes.html#t:Channel">Channel</a></code>s. They each restrict the <code><a href="Tubes.html#t:Tube">Tube</a></code> type in
different ways to guarantee correctness while still allowing them to be
composed. More information is provided with their respective definitions.</p><p>The dual to <code><a href="Tubes.html#t:Tube">Tube</a></code> is <code><a href="Tubes.html#t:Pump">Pump</a></code>. It is a comonad which endows another base comonad
with the ability to <code><a href="Tubes.html#v:send">send</a></code> and <code><a href="Tubes.html#v:recv">recv</a></code> values.</p><p>Several useful <code><a href="Tubes.html#t:Tube">Tube</a></code> functions - like <code><a href="Tubes.html#v:runTube">runTube</a></code>, <code><a href="Tubes.html#v:reduce">reduce</a></code>, and <code><a href="Tubes.html#v:stream">stream</a></code> - are
implemented in terms of <code><a href="Tubes.html#t:Pump">Pump</a></code>. Beyond simply evaluating <code><a href="Tubes.html#t:Tube">Tube</a></code>s they have
other uses. The <code><a href="Tubes.html#v:lfold">lfold</a></code> function, for instance, constructs a resumable left fold
structure.</p><p>This library is inspired in large part by <code>pipes</code>, <code>conduit</code>, and others. While
it intends to be efficient and useful in its own right it began as an exercise
in implementing the basics of those other libraries with comonads and dualities
in mind.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Tube" class="def">Tube</a> a b = FreeT (<a href="Tubes-Core.html#t:TubeF">TubeF</a> a b) <a href="src/Tubes-Core.html#Tube" class="link">Source</a></p><div class="doc"><p>The central data type. <code>Tube</code>s stacked on top of the same base monad <code>m</code> may be
composed in series, so long as their type arguments agree. </p></div></div><div class="top"><p class="src"><a name="v:yield" class="def">yield</a> :: Monad m =&gt; b -&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m () <a href="src/Tubes-Core.html#yield" class="link">Source</a></p><div class="doc"><p>Command telling a <code><a href="Tubes.html#t:Tube">Tube</a></code> computation to yield data downstream and pause.</p></div></div><div class="top"><p class="src"><a name="v:await" class="def">await</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m a <a href="src/Tubes-Core.html#await" class="link">Source</a></p><div class="doc"><p>Command telling a <code><a href="Tubes.html#t:Tube">Tube</a></code> computation to pause and await upstream data.</p></div></div><div class="top"><p class="src"><a name="v:-62--60-" class="def">(&gt;&lt;)</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m r -&gt; <a href="Tubes.html#t:Tube">Tube</a> b c m r -&gt; <a href="Tubes.html#t:Tube">Tube</a> a c m r <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="src/Tubes-Core.html#%3E%3C" class="link">Source</a></p><div class="doc"><p>Compose compatible tubes in series to produce a new <code><a href="Tubes.html#t:Tube">Tube</a></code>.</p><pre>    each [1..10] &gt;<a href="map">(*2)</a>&lt; pour display
</pre></div></div><div class="top"><p class="src"><a name="v:runTube" class="def">runTube</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> () () m r -&gt; m r <a href="src/Tubes-Core.html#runTube" class="link">Source</a></p><div class="doc"><p>Run a self-contained <code><a href="Tubes.html#t:Tube">Tube</a></code> computation.</p></div></div><div class="top"><p class="src"><a name="v:halt" class="def">halt</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m () <a href="src/Tubes-Core.html#halt" class="link">Source</a></p><div class="doc"><p>Command telling a <code><a href="Tubes.html#t:Tube">Tube</a></code> with base type <code>()</code> to simply stop.</p></div></div><h1 id="g:2">Sources</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Source" class="def">Source</a> m a <a href="src/Tubes-Source.html#Source" class="link">Source</a></p><div class="doc"><p>An exhaustible source of values parameterized over a base monad. It never
<code><a href="Tubes.html#v:await">await</a></code>s, it only <code><a href="Tubes.html#v:yield">yield</a></code>s.</p><p><code><a href="Tubes.html#t:Source">Source</a></code>s are monad transformers in their own right, as they are possibly
finite. They may also be synchronously merged:</p><pre>
    src1 :: Source IO String
    src1 = Source $ each [&quot;line A1&quot;, &quot;line A2&quot;, &quot;line A3&quot;]

    src2 :: Source IO String
    src2 = Source $ each [&quot;line B1&quot;, &quot;line B2&quot;, &quot;line B3&quot;, &quot;line B4&quot;]

    src3 :: Source IO String
    src3 = src1 <code><a href="Tubes.html#v:merge">merge</a></code> src2

    main :: IO ()
    main = runTube $ sample src3 &gt;&lt; pour display
    -- line A1
    -- line B1
    -- line A2
    -- line B2
    -- line A3
    -- line B3
    -- line B4
</pre><p>If one source runs out, the other will continue until completion.</p><p>Digression: originally <code><a href="Tubes.html#v:merge">merge</a></code> was the implementation for <code>mappend</code> and '(&lt;&gt;)'.
However because <code><a href="Tubes.html#t:Source">Source</a></code> is ultimately a list transformer I thought it better
that these instances preserve the behavior found in lists and instead provide a
separate function for synchronous merging.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Source" class="def">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:sample" class="def">sample</a> :: <a href="Tubes.html#t:Tube">Tube</a> () a m ()</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Source" class="caption collapser" onclick="toggleSection('i:Source')">Instances</p><div id="section.i:Source" class="show"><table><tr><td class="src clearfix"><span class="inst-left">MonadTrans <a href="Tubes.html#t:Source">Source</a></span> <a href="src/Tubes-Source.html#line-109" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Monad (<a href="Tubes.html#t:Source">Source</a> m)</span> <a href="src/Tubes-Source.html#line-94" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Functor (<a href="Tubes.html#t:Source">Source</a> m)</span> <a href="src/Tubes-Source.html#line-83" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Applicative (<a href="Tubes.html#t:Source">Source</a> m)</span> <a href="src/Tubes-Source.html#line-86" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Alternative (<a href="Tubes.html#t:Source">Source</a> m)</span> <a href="src/Tubes-Source.html#line-99" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; MonadPlus (<a href="Tubes.html#t:Source">Source</a> m)</span> <a href="src/Tubes-Source.html#line-117" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">MonadIO m =&gt; MonadIO (<a href="Tubes.html#t:Source">Source</a> m)</span> <a href="src/Tubes-Source.html#line-114" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(Monad m, Floating a) =&gt; Floating (<a href="Tubes.html#t:Source">Source</a> m a)</span> <a href="src/Tubes-Source.html#line-143" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(Monad m, Fractional a) =&gt; Fractional (<a href="Tubes.html#t:Source">Source</a> m a)</span> <a href="src/Tubes-Source.html#line-138" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(Monad m, Num a) =&gt; Num (<a href="Tubes.html#t:Source">Source</a> m a)</span> <a href="src/Tubes-Source.html#line-128" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Monoid (<a href="Tubes.html#t:Source">Source</a> m a)</span> <a href="src/Tubes-Source.html#line-121" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Semigroup (<a href="Tubes.html#t:Source">Source</a> m a)</span> <a href="src/Tubes-Source.html#line-125" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:reduce" class="def">reduce</a> :: Monad m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Tubes.html#t:Tube">Tube</a> () a m () -&gt; m b <a href="src/Tubes-Source.html#reduce" class="link">Source</a></p><div class="doc"><p>Strict left-fold of a <code><a href="Tubes.html#t:Source">Source</a></code>, using a <code><a href="Tubes.html#t:Pump">Pump</a></code> internally.</p></div></div><div class="top"><p class="src"><a name="v:merge" class="def">merge</a> :: Monad m =&gt; <a href="Tubes.html#t:Source">Source</a> m a -&gt; <a href="Tubes.html#t:Source">Source</a> m a -&gt; <a href="Tubes.html#t:Source">Source</a> m a <a href="src/Tubes-Source.html#merge" class="link">Source</a></p><div class="doc"><p>Interleave the values of two <code><a href="Tubes.html#t:Source">Source</a></code>s until both are exhausted.</p></div></div><h1 id="g:3">Sinks</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Sink" class="def">Sink</a> m a <a href="src/Tubes-Sink.html#Sink" class="link">Source</a></p><div class="doc"><p>A potentially full sink of values parameterized over a base monad. It never
<code><a href="Tubes.html#v:yield">yield</a></code>s.</p><p>A <code><a href="Tubes.html#t:Sink">Sink</a></code> is a contravariant functor. Intuitively this means that it is a
consumer of some base type, and you may map transformations over its input
before it is consumed.</p><p>Example:</p><pre>    import Data.Functor.Contravariant

    add5 :: Sink IO Int
    add5 = Sink $ loop 0 5 where
        loop acc 0 = do
            liftIO $ putStrLn $ &quot;Sum of five numbers: &quot; ++ (show acc)
            halt
        loop acc count = do
            n &lt;- await
            loop (acc + n) (count - 1)

    times2Add5:: Sink IO Int
    times2Add5 = (*2) &gt;$&lt; add5

    main :: IO ()
    main = do
        runTube $ each [1..10] &gt;&lt; pour add5
        -- &quot;Sum of five numbers: 15&quot;

        runTube $ each [1..10] &gt;&lt; pour times2Add5
        -- &quot;Sum of five numbers: 30&quot;
</pre><p><code><a href="Tubes.html#t:Sink">Sink</a></code>s may also be merged together, as they form a semigroup:</p><pre>    import Data.Semigroup

    writeToFile :: Sink IO String
    writeToFile = Sink $ do
        line &lt;- await
        liftIO . putStrLn $ &quot;Totally writing this to a file: &quot; ++ line

    writeToConsole :: Sink IO String
    writeToConsole = Sink $ do
        line &lt;- await
        liftIO . putStrLn $ &quot;Console out: &quot; ++ line

    writeOut :: Sink IO String
    writeOut = writeToFile &lt;&gt; writeToConsole

    main :: IO ()
    main = do
        runTube $ each [1..3] &gt;&lt; map show &gt;&lt; forever (pour writeOut)
        -- Totally writing this to a file: 1
        -- Console out: 1
        -- Totally writing this to a file: 2
        -- Console out: 2
        -- Totally writing this to a file: 3
        -- Console out: 3
</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Sink" class="def">Sink</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:pour" class="def">pour</a> :: <a href="Tubes.html#t:Tube">Tube</a> a () m ()</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Sink" class="caption collapser" onclick="toggleSection('i:Sink')">Instances</p><div id="section.i:Sink" class="show"><table><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Contravariant (<a href="Tubes.html#t:Sink">Sink</a> m)</span> <a href="src/Tubes-Sink.html#line-98" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Divisible (<a href="Tubes.html#t:Sink">Sink</a> m)</span> <a href="src/Tubes-Sink.html#line-101" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Decidable (<a href="Tubes.html#t:Sink">Sink</a> m)</span> <a href="src/Tubes-Sink.html#line-109" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Semigroup (<a href="Tubes.html#t:Sink">Sink</a> m a)</span> <a href="src/Tubes-Sink.html#line-118" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:4">Channels</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Channel" class="def">Channel</a> m a b <a href="src/Tubes-Channel.html#Channel" class="link">Source</a></p><div class="doc"><p>A <code>Channel m a b</code> is a stream processor which converts values of type <code>a</code> into
values of type <code>b</code>, while also performing side-effects in some monad <code>m</code>.</p><p>If a <code>Channel</code> <code><a href="Tubes.html#v:yield">yield</a></code>s exactly once after each time it <code><a href="Tubes.html#v:await">await</a></code>s then it may be
safely treated as an <code>Arrow</code>. For example:</p><pre>    {-# LANGUAGE Arrows #-}

    import Tubes
    import Control.Arrow
    import Prelude hiding (map)

    -- A simple channel which accumulates a total
    total :: (Num a, Monad m) =&gt; Channel m a a
    total = Channel $ loop 0 where
        loop acc = do
            n &lt;- await
            let acc' = n + acc
            yield acc'
            loop acc'

    -- A running average using two totals in parallel
    avg :: (Fractional a, Monad m) =&gt; Channel m a a
    avg = proc value -&gt; do
        t &lt;- total -&lt; value
        n &lt;- total -&lt; 1
        returnA -&lt; t / n

    main :: IO ()
    main = runTube $ each [0,10,7,8]
                  &gt;&lt; tune avg
                  &gt;&lt; map show
                  &gt;&lt; pour display

</pre><p>This program would output</p><pre>    0.0
    5.0
    5.666666666666667
    6.25
</pre><p>This has interesting potential in FRP applications.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Channel" class="def">Channel</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:tune" class="def">tune</a> :: <a href="Tubes.html#t:Tube">Tube</a> a b m ()</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Channel" class="caption collapser" onclick="toggleSection('i:Channel')">Instances</p><div id="section.i:Channel" class="show"><table><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Category * (<a href="Tubes.html#t:Channel">Channel</a> m)</span> <a href="src/Tubes-Channel.html#line-90" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Arrow (<a href="Tubes.html#t:Channel">Channel</a> m)</span> <a href="src/Tubes-Channel.html#line-94" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">Monad m =&gt; Profunctor (<a href="Tubes.html#t:Channel">Channel</a> m)</span> <a href="src/Tubes-Channel.html#line-86" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:tee" class="def">tee</a> :: Monad m =&gt; <a href="Tubes.html#t:Sink">Sink</a> m a -&gt; <a href="Tubes.html#t:Channel">Channel</a> m a a <a href="src/Tubes-Channel.html#tee" class="link">Source</a></p><div class="doc"><p>Convert a 'Sink m a' into a 'Channel m a a', re-forwarding values downstream.</p><p>Useful example:</p><pre>    import Data.Semigroup

    writeToFile :: Sink IO String
    writeToFile = Sink $ do
        line &lt;- await
        liftIO . putStrLn $ &quot;Totally writing this to a file: &quot; ++ line

    writeToConsole :: Sink IO String
    writeToConsole = Sink $ do
        line &lt;- await
        liftIO . putStrLn $ &quot;Console out: &quot; ++ line

    writeOut :: Channel IO String String
    writeOut = tee $ writeToFile &lt;&gt; writeToConsole

    main :: IO ()
    main = runTube $ each [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] &gt;&lt; forever (tune writeOut) &gt;&lt; pour display
    --  Totally writing this to a file: a
    --  Console out: a
    --  a
    --  Totally writing this to a file: b
    --  Console out: b
    --  b
    --  Totally writing this to a file: c
    --  Console out: c
    --  c
</pre><p>This takes advantage of the divisible nature of <code><a href="Tubes.html#t:Sink">Sink</a></code>s to merge effectful
computations and then continue the process.</p></div></div><h1 id="g:5">Pump</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Pump" class="def">Pump</a> b a = CofreeT (<a href="Tubes-Core.html#t:PumpF">PumpF</a> b a) <a href="src/Tubes-Core.html#Pump" class="link">Source</a></p><div class="doc"><p>Pumps are the dual of <code><a href="Tubes.html#t:Tube">Tube</a></code>s. Where a <code><a href="Tubes.html#t:Tube">Tube</a></code> may either be <code><a href="Tubes.html#v:await">await</a></code>ing or
<code><a href="Tubes.html#v:yield">yield</a></code>ing, a <code><a href="Tubes.html#t:Pump">Pump</a></code> is always in a position to <code><a href="Tubes.html#v:send">send</a></code> or <code><a href="Tubes.html#v:recv">recv</a></code> data. They are
the machines which run <code><a href="Tubes.html#t:Tube">Tube</a></code>s, essentially.</p><p>Pumps may be used to formulate infinite streams and folds.</p><p>TODO: more examples!</p><p>Note the type arguments are &quot;backward&quot; from the <code><a href="Tubes.html#t:Tube">Tube</a></code> point of view: a
<code>Pump b a w r</code> may be sent values of type <code>a</code> and you may receive <code>b</code> values
from it.</p></div></div><div class="top"><p class="src"><a name="v:send" class="def">send</a> :: Comonad w =&gt; b -&gt; <a href="Tubes.html#t:Pump">Pump</a> a b w r -&gt; <a href="Tubes.html#t:Pump">Pump</a> a b w r <a href="src/Tubes-Core.html#send" class="link">Source</a></p><div class="doc"><p>Send a <code><a href="Tubes.html#t:Pump">Pump</a></code> a value, yielding a new <code><a href="Tubes.html#t:Pump">Pump</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:recv" class="def">recv</a> :: Comonad w =&gt; <a href="Tubes.html#t:Pump">Pump</a> a b w r -&gt; (a, <a href="Tubes.html#t:Pump">Pump</a> a b w r) <a href="src/Tubes-Core.html#recv" class="link">Source</a></p><div class="doc"><p>Receive a value from a <code><a href="Tubes.html#t:Pump">Pump</a></code>, along with a new <code><a href="Tubes.html#t:Pump">Pump</a></code> for the future.</p></div></div><div class="top"><p class="src"><a name="v:pumpT" class="def">pumpT</a> :: Comonad w =&gt; w r -&gt; (w r -&gt; b -&gt; w r) -&gt; (w r -&gt; (a, w r)) -&gt; <a href="Tubes.html#t:Pump">Pump</a> a b w r <a href="src/Tubes-Core.html#pumpT" class="link">Source</a></p><div class="doc"><p>Construct a <code><a href="Tubes.html#t:Pump">Pump</a></code> based on an arbitrary comonad.</p></div></div><div class="top"><p class="src"><a name="v:lfold" class="def">lfold</a> :: (x -&gt; a -&gt; x) -&gt; (x -&gt; (b, x)) -&gt; x -&gt; <a href="Tubes.html#t:Pump">Pump</a> b a Identity x <a href="src/Tubes-Util.html#lfold" class="link">Source</a></p><div class="doc"><p>Constructs a resumable left fold. Example usage:</p><pre>    summer :: Pump () Int Identity Int
    summer = lfold (+) (x -&gt; ((),x)) 0

    main :: IO ()
    main = do
        result &lt;- stream const (duplicate summer) $ each [1..10]
        putStrLn . show . extract $ result -- &quot;55&quot;
        result2 &lt;- stream const (duplicate result) $ each [11..20]
        putStrLn . show . extract $ result2 -- &quot;210&quot;
</pre></div></div><h1 id="g:6">Utilities</h1><div class="top"><p class="src"><a name="v:stream" class="def">stream</a> :: (Monad m, Comonad w) =&gt; (a -&gt; b -&gt; r) -&gt; <a href="Tubes.html#t:Pump">Pump</a> c d w a -&gt; <a href="Tubes.html#t:Tube">Tube</a> c d m b -&gt; m r <a href="src/Tubes-Core.html#stream" class="link">Source</a></p><div class="doc"><p>Process a <code><a href="Tubes.html#t:Tube">Tube</a></code> stream with a given <code><a href="Tubes.html#t:Pump">Pump</a></code>, and merge their results.</p></div></div><div class="top"><p class="src"><a name="v:streamM" class="def">streamM</a> :: (Monad m, Comonad w) =&gt; (a -&gt; b -&gt; r) -&gt; <a href="Tubes.html#t:Pump">Pump</a> c d w (m a) -&gt; <a href="Tubes.html#t:Tube">Tube</a> c d m b -&gt; m r <a href="src/Tubes-Core.html#streamM" class="link">Source</a></p><div class="doc"><p>Process a <code><a href="Tubes.html#t:Tube">Tube</a></code> stream with an effectful <code><a href="Tubes.html#t:Pump">Pump</a></code>, and merge their results.</p></div></div><div class="top"><p class="src"><a name="v:cat" class="def">cat</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m r <a href="src/Tubes-Util.html#cat" class="link">Source</a></p><div class="doc"><p>Continuously relays any values it receives.</p></div></div><div class="top"><p class="src"><a name="v:for" class="def">for</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m r -&gt; (b -&gt; <a href="Tubes.html#t:Tube">Tube</a> a c m s) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a c m r <a href="src/Tubes-Util.html#for" class="link">Source</a></p><div class="doc"><p>Loops over a <code><a href="Tubes.html#t:Tube">Tube</a></code> and gives each <code><a href="Tubes.html#v:yield">yield</a></code>ed value to the continuation.</p></div></div><div class="top"><p class="src"><a name="v:each" class="def">each</a> :: (Monad m, Foldable t) =&gt; t b -&gt; <a href="Tubes.html#t:Tube">Tube</a> () b m () <a href="src/Tubes-Util.html#each" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:every" class="def">every</a> :: (Foldable t, Monad m) =&gt; t b -&gt; <a href="Tubes.html#t:Tube">Tube</a> () (Maybe b) m () <a href="src/Tubes-Util.html#every" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:map" class="def">map</a> :: Monad m =&gt; (a -&gt; b) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m r <a href="src/Tubes-Util.html#map" class="link">Source</a></p><div class="doc"><p>Transforms all incoming values according to some function.</p></div></div><div class="top"><p class="src"><a name="v:drop" class="def">drop</a> :: Monad m =&gt; Int -&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m r <a href="src/Tubes-Util.html#drop" class="link">Source</a></p><div class="doc"><p>Refuses to yield the first <code>n</code> values it receives.</p></div></div><div class="top"><p class="src"><a name="v:take" class="def">take</a> :: Monad m =&gt; Int -&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m () <a href="src/Tubes-Util.html#take" class="link">Source</a></p><div class="doc"><p>Relay only the first <code>n</code> elements of a stream.</p></div></div><div class="top"><p class="src"><a name="v:takeWhile" class="def">takeWhile</a> :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m () <a href="src/Tubes-Util.html#takeWhile" class="link">Source</a></p><div class="doc"><p>Terminates the stream upon receiving a value violating the predicate</p></div></div><div class="top"><p class="src"><a name="v:filter" class="def">filter</a> :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a a m r <a href="src/Tubes-Util.html#filter" class="link">Source</a></p><div class="doc"><p>Yields only values satisfying some predicate.</p></div></div><div class="top"><p class="src"><a name="v:unyield" class="def">unyield</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> x b m () -&gt; m (Maybe (b, <a href="Tubes.html#t:Tube">Tube</a> x b m ())) <a href="src/Tubes-Util.html#unyield" class="link">Source</a></p><div class="doc"><p>Taps the next value from a source, maybe.</p></div></div><div class="top"><p class="src"><a name="v:pass" class="def">pass</a> :: Monad m =&gt; a -&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m () -&gt; m (Maybe (b, <a href="Tubes.html#t:Tube">Tube</a> a b m ())) <a href="src/Tubes-Util.html#pass" class="link">Source</a></p><div class="doc"><p>Similar to <code><a href="Tubes.html#v:unyield">unyield</a></code> but it first sends a value through the tube.</p></div></div><div class="top"><p class="src"><a name="v:mapM" class="def">mapM</a> :: Monad m =&gt; (a -&gt; m b) -&gt; <a href="Tubes.html#t:Tube">Tube</a> a b m r <a href="src/Tubes-Util.html#mapM" class="link">Source</a></p><div class="doc"><p>Similar to <code><a href="Tubes.html#v:map">map</a></code> except it maps a monadic function instead of a pure one.</p></div></div><div class="top"><p class="src"><a name="v:sequence" class="def">sequence</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> (m a) a m r <a href="src/Tubes-Util.html#sequence" class="link">Source</a></p><div class="doc"><p>Evaluates and extracts a pure value from a monadic one.</p></div></div><div class="top"><p class="src"><a name="v:stop" class="def">stop</a> :: Monad m =&gt; <a href="Tubes.html#t:Tube">Tube</a> a () m r <a href="src/Tubes-Util.html#stop" class="link">Source</a></p><div class="doc"><p>A default tube to end a series when no further processing is required.</p></div></div><h1 id="g:7">Miscellaneous</h1><div class="top"><p class="src"><a name="v:prompt" class="def">prompt</a> :: MonadIO m =&gt; <a href="Tubes.html#t:Source">Source</a> m String <a href="src/Tubes.html#prompt" class="link">Source</a></p><div class="doc"><p>Source of <code>String</code>s from stdin. This is mostly for debugging / ghci example purposes.</p></div></div><div class="top"><p class="src"><a name="v:display" class="def">display</a> :: MonadIO m =&gt; <a href="Tubes.html#t:Sink">Sink</a> m String <a href="src/Tubes.html#display" class="link">Source</a></p><div class="doc"><p>Sink for <code>String</code>s to stdout. This is mostly for debugging / ghci example
 purposes.</p></div></div><h1 id="g:8">Re-exports</h1><div class="top"><p class="src"><a name="v:liftT" class="def">liftT</a> :: (MonadTrans t, Monad m) =&gt; FreeT f m a -&gt; t m (FreeF f a (FreeT f m a)) <a href="src/Tubes-Core.html#liftT" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:runFreeT" class="def">runFreeT</a> :: FreeT f m a -&gt; m (FreeF f a (FreeT f m a))</p></div><h1 id="g:9">Example</h1><div class="doc"><p>Code is worth a thousand words. This program ...</p><pre>    import Prelude hiding (map)
    import qualified Prelude as P

    import Data.Semigroup
    import Control.Monad (forever)

    import Tubes

    srcA :: MonadIO m =&gt; Source m String
    srcA = Source $ each [&quot;line A1&quot;, &quot;line A2&quot;, &quot;line A3&quot;]

    srcB :: MonadIO m =&gt; Source m String
    srcB = Source $ each [&quot;line B1&quot;, &quot;line B2&quot;, &quot;line B3&quot;, &quot;line B4&quot;]

    -- Synchronously merge input
    srcAB :: MonadIO m =&gt; Source m String
    srcAB = srcA <code><a href="Tubes.html#v:merge">merge</a></code> srcB

    writeToFile :: MonadIO m =&gt; Sink m String
    writeToFile = Sink $ do
        line &lt;- await
        liftIO . putStrLn $ &quot;Totally writing this to a file: &quot; ++ line

    writeToConsole :: MonadIO m =&gt; Sink m String
    writeToConsole = Sink $ do
        line &lt;- await
        liftIO . putStrLn $ &quot;Console out: &quot; ++ line

    -- Merge outputs together
    writeOut :: MonadIO m =&gt; Sink m String
    writeOut = writeToFile &lt;&gt; writeToConsole

    -- And make outputs re-forward their input data
    writeOut' :: MonadIO m =&gt; Channel m String String
    writeOut' = tee writeOut

    main :: IO ()
    main = runTube $ sample srcAB
                  &gt;&lt; tune writeOut'
                  &gt;&lt; pour display
</pre><p>... gives this output:</p><pre>    Totally writing this to a file: line A1
    Console out: line A1
    line A1
    Totally writing this to a file: line B1
    Console out: line B1
    line B1
    Totally writing this to a file: line A2
    Console out: line A2
    line A2
    Totally writing this to a file: line B2
    Console out: line B2
    line B2
    Totally writing this to a file: line A3
    Console out: line A3
    line A3
    Totally writing this to a file: line B3
    Console out: line B3
    line B3
    Totally writing this to a file: line B4
    Console out: line B4
    line B4
</pre></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>